# NASSCOM-VSD SOC Physical Design Training

#  RTL to GDSII flow using OpenLane

This training will guide you through the process of designing an Application Specific Integrated Circuit (ASIC) using the OpenLane ASIC flow. We will cover everything from the Register Transfer Level (RTL) design to generating the final Graphical Data System (GDS) file. The process involves several critical steps, starting with an RTL file and ending with a GDS file.

## Key Learnings

### RTL to GDS Flow

1. **End-to-End Process**:
   - Gained a comprehensive understanding of transforming a high-level hardware description into a physical ASIC layout.
   - Appreciated the significance of each stage in the flow, from synthesis to sign-off.

2. **Synthesis**:
   - Learned how RTL code is converted into a gate-level netlist using standard cell libraries.
   - Identified various cell views including Liberty, HDL, SPICE, and Layout.

3. **Floor and Power Planning**:
   - Understood the importance of floor planning for chip partitioning and I/O pad placement.

## Day 1

![image](https://github.com/user-attachments/assets/f2cfebff-40c1-4659-b5cb-abc5c2be2006)


## RISC-V Architecture

The RISC-V architecture is built on the principles of Reduced Instruction Set Computing (RISC) and is notable for being open-source, allowing anyone to design and implement a RISC-V CPU without paying licensing fees. This openness has created a collaborative environment, enabling contributions from a wide range of organizations, including both startups and industry leaders like Google and Intel.

A key characteristic of RISC-V is its modular design. The architecture includes a mandatory base ISA (Instruction Set Architecture) that can be extended with various optional components, allowing for customization based on specific application needs. For example, the RV32IMAC designation refers to a 32-bit CPU featuring the base integer ISA along with extensions for multiplication, atomic operations, and compressed instructions. This modularity enables developers to create CPUs that balance performance, power consumption, and complexity according to their requirements.

RISC-V is gaining widespread adoption across diverse industries such as cloud computing, automotive, and the Internet of Things (IoT). Companies are increasingly leveraging RISC-V to design custom chips optimized for specific tasks, like artificial intelligence and data processing. The architecture's adaptability and scalability make it ideal for a variety of devices, from high-performance servers to energy-efficient embedded systems. The RISC-V International organization, a nonprofit, governs the development and standardization of the RISC-V ISA. This group ensures that the architecture evolves with a focus on community-driven innovation rather than commercial interests, further solidifying its popularity within the tech community.

## Bridging Software Applications and Hardware

In everyday use, we interact with application software (apps) to control hardware devices. This interaction happens like this, Between the application software and the hardware, there is an intermediary layer known as system software. This layer acts as a bridge, converting application requests into a format that hardware can interpret, specifically binary language.

![image](https://github.com/user-attachments/assets/a9ec542f-278d-43fc-9428-095b3e4a264b)

- **Operating System (OS)**: The OS manages fundamental tasks such as input/output operations, memory management, and system-level functions. It also plays a crucial role in translating application software into machine-readable code in languages like C, C++, or Java.

- **Compiler**: The compiler processes the code generated by the OS and translates it into machine code or executable files (e.g., .exe files). This code is specifically designed to be executed on the hardware platform in use.

- **Assembler**: The assembler further converts these executable files into binary code. This binary code is the language that the hardware can interpret and execute to perform the required tasks.

# Overview of IC Design Elements and Terminology

## Core

The core is the central section of an integrated circuit (IC) where the essential logic functions are executed. It encompasses all combinational circuits as well as both soft and hard intellectual property (IP) blocks.

## Die

A die is the individual unit of semiconductor material that houses the core and the input/output (IO) pads. Multiple dies are manufactured on a single silicon wafer to optimize production efficiency.

## IO Pads

IO pads are the interface points that enable communication between the chip's core and the external environment. These pads include input, output, and power pads, facilitating the connection of the chip to other components.

## Intellectual Property (IP)

Foundry IPs are pre-designed circuit modules that can be reused across various designs. These may include elements like SRAM, ADCs, DACs, and PLLs, which often require custom design or human expertise.

## Process Design Kits (PDKs)

Process Design Kits (PDKs) act as a crucial link between design engineers and semiconductor fabrication plants. They contain essential files that model fabrication processes, including device models, design rule checks (DRC), layout versus schematic (LVS) checks, and standard cell libraries. For example, the SkyWater 130nm PDK is frequently used in IC design workshops.



# Overview of the RTL to GDSII Flow

The RTL to GDSII flow in VLSI design transforms an RTL (Register Transfer Level) description of a digital circuit into a physical layout prepared for manufacturing. This process includes several stages: RTL synthesis, floor planning, placement, routing, and ultimately generating the GDSII file format, which holds the layout data. Each stage ensures that the final integrated circuit (IC) layout accurately represents the intended functionality and adheres to fabrication standards.

## Specification and RTL Coding

The design process starts with a specification provided by the customer, detailing the required functionality of the chip. This specification is then converted into Register Transfer Level (RTL) code using Hardware Description Languages (HDL) such as Verilog or VHDL.

## Simulation and Verification

Once the RTL coding is complete, the design undergoes simulation to verify its functionality. This step ensures that the design operates as intended before moving to the next stage. Verification engineers thoroughly test the RTL code to identify and correct any bugs, ensuring the design's accuracy.

## Logic Synthesis

After successful verification, the RTL code is synthesized into a gate-level netlist. This involves translating the high-level design into an optimized format that can be implemented using standard cells from a technology library. Logic Equivalence Checking (LEC) is performed to confirm that the synthesized design retains the functionality of the original RTL code.

## Physical Design (Place and Route)

The physical design phase follows, encompassing floorplanning, placement, and routing of the netlist. This stage focuses on organizing the components on the silicon die, optimizing for area, and maintaining signal integrity. The final product of this phase is a GDSII file, the industry-standard format for layout data.

## Signoff and Tapeout

Before the design is sent for fabrication, it undergoes several signoff checks to ensure it meets all specifications and design rules. This final verification step is crucial for identifying any critical errors. Upon approval, the GDSII file is sent for fabrication, marking the tapeout phase and the completion of the design process.

![image](https://github.com/user-attachments/assets/53c70a9b-9f2b-47ab-8232-3b7ec3d96246)

## Importance of the RTL to GDSII Flow

The RTL to GDSII flow is vital for the following reasons:

- **Complexity Management**: It breaks down the complex chip design process into manageable stages, allowing for systematic development and verification.
- **Efficiency**: Automated tools for synthesis, verification, and layout significantly reduce the time required to move a chip from concept to production, typically within 6 to 24 months, depending on the design complexity.
- **Quality Assurance**: The flow includes multiple checks and validations to ensure that the final design meets high standards for performance and reliability.
- **Industry Relevance**: Mastery of the RTL to GDSII flow is essential for engineers in the semiconductor industry, as it encompasses the critical skills required for modern chip design and implementation.

#  Overview of OpenLane - Open-Source Digital ASIC Design

### Introduction

OpenLane has proven its effectiveness in real-world applications through successful tape-outs of RISC-V based SoCs. The project continues to advance, with significant enhancements in SystemVerilog support and user experience features in OpenLane 2.

### Purpose

OpenLane facilitates the transition from Register Transfer Level (RTL) design to GDSII layout, which is crucial for ASIC manufacturing. It is designed to address two primary use cases:
- **Macro Hardening**: Converting a macro from its HDL representation into a manufacturable layout.
- **SoC Integration**: Combining multiple macros into a cohesive System-on-a-Chip (SoC) design.

# OpenLANE ASIC Design Flow

The diagram below depicts the comprehensive ASIC design flow implemented in OpenLANE. The process starts with the Design RTL (Register Transfer Level), which is then synthesized into an optimized gate-level netlist using Yosys and ABC. This netlist is subsequently analyzed using Static Timing Analysis (STA) to identify any potential timing violations. Optionally, the flow can include Design for Test (DFT), utilizing the FAULT tool to enhance testability.

![image](https://github.com/user-attachments/assets/ea2a0188-3dd8-4378-ae46-e159f85a976f)


### Components

The OpenLane flow utilizes a range of open-source Electronic Design Automation (EDA) tools, including:
- **Yosys**: For synthesis
- **OpenROAD**: For placement and routing
- **Magic**: For layout editing
- **KLayout**: For layout viewing and verification

These tools work in concert to automate various stages of the ASIC design process, from synthesis to physical verification.


![image](https://github.com/user-attachments/assets/e3cf9c1d-e3b9-47e3-b18d-72dfb616b1b5)



### Versions

OpenLane is available in two main versions:
- **OpenLane 1**: A stable platform ideal for general ASIC designs, especially for multi-project wafer (MPW) programs.
- **OpenLane 2**: A more adaptable and customizable platform that supports user-defined ASIC implementation flows, making it suitable for complex designs.

## Features and Benefits

- **Automation**: OpenLane automates the complete ASIC design flow, allowing users to concentrate on design rather than tool integration complexities. This includes full automation of synthesis, placement, routing, and verification.
  
- **Customizability**: Users can create custom design flows using Python scripts, offering high flexibility for advanced design needs. This is especially valuable for users requiring specific functionalities not available in standard flows.

- **Open-Source Ecosystem**: OpenLane is part of the open-source ASIC design movement, aimed at democratizing access to advanced design tools and fostering collaboration and innovation within the design community.

## Use Cases

- **Macro Hardening**: This process converts HDL designs into manufacturable layouts, allowing for the reuse of hardened macros across different projects, thereby enhancing design efficiency and consistency.

- **SoC Integration**: OpenLane supports the integration of various macros into a complete chip design, which is crucial for developing complex SoCs that incorporate multiple functional blocks.

# RTL2GDS OpenLANE ASIC Flow: Practical Implementation

## Day 1 Labs

### Linux Command Basics

1. **pwd**: Displays the current working directory path.
2. **ls**: Lists all files and directories in the current location.
3. **cd**: Navigate between directories within the directory tree.
4. **mkdir**: Creates a new directory.
5. **rmdir**: Deletes an empty directory.
6. **rm**: Removes files or directories.
7. **cp**: Copies files or directories.
8. **mv**: Moves or renames files or directories.
9. **cat**: Displays the contents of a file.
10. **clear**: Clears the terminal screen.
11. **help**: Provides information on the usage of other commands.

### File extensions and their Purpose

  - **libs.ref**: Contains design libraries essential for the ASIC flow.
  - **lef**: Library Exchange Format files describing cell layouts.
  - **lib**: Liberty files used for timing and power analysis.
  - **gds**: GDSII files containing the graphical layout of cells.
  - **verilog**: Verilog models for simulation and design verification.
  - **libs.tech**: Technology files tailored for EDA tools.
  - **magic**: Files specific to Magic layout tool.
  - **klayout**: KLayout technology files and layer properties.
  - **ngspice**: SPICE models for circuit simulations.
  - **openroad**: Configuration files for OpenROAD flow.
  - **drc**: Design Rule Check files.
  - **lvs**: Layout Versus Schematic check files.
  - **pex**: Parasitic Extraction files.

## Flowchart for running synthesis in OpenLane

![image](https://github.com/user-attachments/assets/28c7a0db-320a-4083-b461-03a93f7a7365)


### Proceed with the steps outlined

To start working with OpenLane, open your terminal and navigate to the following directory:

     cd /Desktop/work/tools/openlane_working_dir/openlane

#### Running OpenLane in Docker

Execute the following command to run OpenLane in Docker:

     docker


![Screenshot 2024-08-29 121716](https://github.com/user-attachments/assets/44931662-412a-442e-97f6-0ed8344321fb)


To start the tool in interactive mode, execute the following command:

`bash`

./flow.tcl -interactive

To import the required package and prepare the design, execute the command below:

    % package require openlane 0.9
    % prep -design picorv32a

![Screenshot 2024-08-29 123504](https://github.com/user-attachments/assets/73d536fc-c0a1-45ba-8031-c84ab22cb9f3)

## Directory Structure

Once the preparation process is complete, a new directory, named with the current date, will be created inside the `runs` folder. This directory will contain all the required subdirectories for storing results, reports, and other relevant data. A new directory structure will be set up to organize the design files, with subdirectories designated for different components like results and reports.


- **src**: Contains Verilog files and constraints file
- **LEF Merging**:
  The technology LEF (.tlef) and cell LEF (.lef) files are merged into a single format. The technology LEF contains layer information (e.g., metal layers), while the cell LEF includes cell information.

- **Design Placement**:
  All design-related files are placed under the `designs` directory to ensure they are well-organized and accessible for subsequent steps.

 
